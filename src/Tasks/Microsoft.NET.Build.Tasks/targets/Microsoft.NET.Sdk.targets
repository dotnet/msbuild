<!--
***********************************************************************************************
Microsoft.NET.Sdk.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- Workaround: https://github.com/Microsoft/msbuild/issues/1293 -->
  <PropertyGroup Condition="'$(MSBuildRuntimeType)' == 'Core' Or '$(TargetFrameworkIdentifier)' != '.NETFramework'">
    <GenerateResourceMSBuildArchitecture Condition=" '$(GenerateResourceMSBuildArchitecture)' == '' ">CurrentArchitecture</GenerateResourceMSBuildArchitecture>
    <GenerateResourceMSBuildRuntime Condition=" '$(GenerateResourceMSBuildRuntime)' == '' ">CurrentRuntime</GenerateResourceMSBuildRuntime>
  </PropertyGroup>

  <Import Project="Microsoft.NET.Sdk.Common.targets" />

  <ImportGroup>
    <Import Project="$(MSBuildThisFileDirectory)Microsoft.PackageDependencyResolution.targets" Condition="Exists('$(MSBuildThisFileDirectory)Microsoft.PackageDependencyResolution.targets')" />
  </ImportGroup>

  <Import Project="Microsoft.NET.Sdk.DefaultItems.targets" />

  <Import Project="Microsoft.NET.Sdk.TargetingPackResolution.targets" />

  <UsingTask TaskName="GenerateDepsFile" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="GenerateRuntimeConfigurationFiles" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="GetAssemblyVersion" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="GenerateSatelliteAssemblies" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />

  <PropertyGroup>
    <DisableStandardFrameworkResolution Condition="'$(DisableStandardFrameworkResolution)' == ''">$(_IsNETCoreOrNETStandard)</DisableStandardFrameworkResolution>
  </PropertyGroup>

  <PropertyGroup>
    <GenerateRuntimeConfigurationFiles Condition=" '$(GenerateRuntimeConfigurationFiles)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and ('$(HasRuntimeOutput)' == 'true' or '$(UseComHost)' == 'true') ">true</GenerateRuntimeConfigurationFiles>
    <UserRuntimeConfig Condition=" '$(UserRuntimeConfig)' == '' ">$(MSBuildProjectDirectory)/runtimeconfig.template.json</UserRuntimeConfig>
    <GenerateSatelliteAssembliesForCore Condition=" '$(GenerateSatelliteAssembliesForCore)' == '' and '$(MSBuildRuntimeType)' == 'Core' ">true</GenerateSatelliteAssembliesForCore>
    <ComputeNETCoreBuildOutputFiles Condition=" '$(ComputeNETCoreBuildOutputFiles)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">true</ComputeNETCoreBuildOutputFiles>
  </PropertyGroup>

  <ItemGroup>
    <GenerateRuntimeConfigurationFilesInputs Include="$(ProjectAssetsFile)" />
    <GenerateRuntimeConfigurationFilesInputs Include="$(UserRuntimeConfig)" Condition=" Exists($(UserRuntimeConfig)) " />
  </ItemGroup>

  <PropertyGroup>
    <ProjectDepsFileName Condition="'$(ProjectDepsFileName)' == ''">$(AssemblyName).deps.json</ProjectDepsFileName>
    <ProjectDepsFilePath Condition="'$(ProjectDepsFilePath)' == ''">$(TargetDir)$(ProjectDepsFileName)</ProjectDepsFilePath>
    <ProjectRuntimeConfigFileName Condition="'$(ProjectRuntimeConfigFileName)' == ''">$(AssemblyName).runtimeconfig.json</ProjectRuntimeConfigFileName>
    <ProjectRuntimeConfigFilePath Condition="'$(ProjectRuntimeConfigFilePath)' == ''">$(TargetDir)$(ProjectRuntimeConfigFileName)</ProjectRuntimeConfigFilePath>
    <ProjectRuntimeConfigDevFilePath Condition="'$(ProjectRuntimeConfigDevFilePath)' == ''">$(TargetDir)$(AssemblyName).runtimeconfig.dev.json</ProjectRuntimeConfigDevFilePath>
    <IncludeMainProjectInDepsFile Condition=" '$(IncludeMainProjectInDepsFile)' == '' ">true</IncludeMainProjectInDepsFile>
  </PropertyGroup>

  <PropertyGroup>
    <_NativeLibraryPrefix Condition="'$(_NativeLibraryPrefix)' == '' and !$(RuntimeIdentifier.StartsWith('win'))">lib</_NativeLibraryPrefix>

    <_NativeLibraryExtension Condition="'$(_NativeLibraryExtension)' == '' and $(RuntimeIdentifier.StartsWith('win'))">.dll</_NativeLibraryExtension>
    <_NativeLibraryExtension Condition="'$(_NativeLibraryExtension)' == '' and $(RuntimeIdentifier.StartsWith('osx'))">.dylib</_NativeLibraryExtension>
    <_NativeLibraryExtension Condition="'$(_NativeLibraryExtension)' == ''">.so</_NativeLibraryExtension>

    <_NativeExecutableExtension Condition="'$(_NativeExecutableExtension)' == '' and ($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win')))">.exe</_NativeExecutableExtension>
    <_ComHostLibraryExtension Condition="'$(_ComHostLibraryExtension)' == '' and ($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win')))">.dll</_ComHostLibraryExtension>

    <_DotNetHostExecutableName>dotnet$(_NativeExecutableExtension)</_DotNetHostExecutableName>
    <_DotNetAppHostExecutableNameWithoutExtension>apphost</_DotNetAppHostExecutableNameWithoutExtension>
    <_DotNetAppHostExecutableName>$(_DotNetAppHostExecutableNameWithoutExtension)$(_NativeExecutableExtension)</_DotNetAppHostExecutableName>

    <_DotNetComHostLibraryNameWithoutExtension>comhost</_DotNetComHostLibraryNameWithoutExtension>
    <_DotNetComHostLibraryName>$(_DotNetComHostLibraryNameWithoutExtension)$(_ComHostLibraryExtension)</_DotNetComHostLibraryName>
    <_DotNetHostPolicyLibraryName>$(_NativeLibraryPrefix)hostpolicy$(_NativeLibraryExtension)</_DotNetHostPolicyLibraryName>
    <_DotNetHostFxrLibraryName>$(_NativeLibraryPrefix)hostfxr$(_NativeLibraryExtension)</_DotNetHostFxrLibraryName>
  </PropertyGroup>

  <PropertyGroup>
    <_DefaultUserProfileRuntimeStorePath>$(HOME)</_DefaultUserProfileRuntimeStorePath>
    <_DefaultUserProfileRuntimeStorePath Condition="'$(OS)' == 'Windows_NT'">$(USERPROFILE)</_DefaultUserProfileRuntimeStorePath>
    <_DefaultUserProfileRuntimeStorePath>$([System.IO.Path]::Combine($(_DefaultUserProfileRuntimeStorePath), '.dotnet', 'store'))</_DefaultUserProfileRuntimeStorePath>
    <UserProfileRuntimeStorePath Condition="'$(UserProfileRuntimeStorePath)' == ''">$(_DefaultUserProfileRuntimeStorePath)</UserProfileRuntimeStorePath>
  </PropertyGroup>

  <PropertyGroup>
    <CoreBuildDependsOn>
      _CheckForBuildWithNoBuild;
      $(CoreBuildDependsOn);
      GenerateBuildDependencyFile;
      GenerateBuildRuntimeConfigurationFiles
    </CoreBuildDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <CoreCleanDependsOn>
      _SdkBeforeClean;
      $(CoreCleanDependsOn)
    </CoreCleanDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <RebuildDependsOn>
      _SdkBeforeRebuild;
      $(RebuildDependsOn)
    </RebuildDependsOn>
  </PropertyGroup>

  <!-- TODO: this target should not check GeneratePackageOnBuild.
             remove when https://github.com/NuGet/Home/issues/7801 is fixed.
    -->
  <Target Name="_CheckForBuildWithNoBuild"
          Condition="'$(NoBuild)' == 'true' and '$(GeneratePackageOnBuild)' != 'true'">
    <NETSdkError ResourceName="NoBuildRequested" />
  </Target>

  <!--
    ============================================================
                                        GenerateBuildDependencyFile

    Generates the $(project).deps.json file during Build
    ============================================================
    -->

  <Target Name="GenerateBuildDependencyFile"
          DependsOnTargets="_DefaultMicrosoftNETPlatformLibrary;
                            _HandlePackageFileConflicts;
                            _ComputeReferenceAssemblies;
                            ResolveRuntimePackAssets"
          BeforeTargets="CopyFilesToOutputDirectory"
          Condition="'$(GenerateDependencyFile)' == 'true'"
          Inputs="$(ProjectAssetsFile);$(MSBuildAllProjects)"
          Outputs="$(ProjectDepsFilePath)">

    <ItemGroup>
      <ResolvedCompileFileDefinitions Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' == 'Reference'" />
      <NativeCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <ResourceCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimeCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimeTargetsCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimePackAsset Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
    </ItemGroup>
    
    <GenerateDepsFile ProjectPath="$(MSBuildProjectFullPath)"
                      AssetsFilePath="$(ProjectAssetsFile)"
                      DepsFilePath="$(ProjectDepsFilePath)"
                      TargetFramework="$(TargetFrameworkMoniker)"
                      AssemblyName="$(AssemblyName)"
                      AssemblyExtension="$(TargetExt)"
                      AssemblyVersion="$(Version)"
                      AssemblySatelliteAssemblies="@(IntermediateSatelliteAssembliesWithTargetPath)"
                      ReferencePaths="@(ReferencePath)"
                      ReferenceDependencyPaths="@(ReferenceDependencyPaths)"
                      ReferenceSatellitePaths="@(ReferenceSatellitePaths)"
                      ReferenceAssemblies="@(_ReferenceAssemblies)"
                      RuntimePackAssets="@(RuntimePackAsset)"
                      IncludeMainProject="$(IncludeMainProjectInDepsFile)"
                      RuntimeIdentifier="$(RuntimeIdentifier)"
                      PlatformLibraryName="$(MicrosoftNETPlatformLibrary)"
                      RuntimeFrameworks="@(RuntimeFramework)"
                      FilesToSkip="@(_ConflictPackageFiles)"
                      CompilerOptions="@(DependencyFileCompilerOptions)"
                      CompileReferences="@(ResolvedCompileFileDefinitions)"
                      ResolvedNuGetFiles="@(NativeCopyLocalItems);@(ResourceCopyLocalItems);@(RuntimeCopyLocalItems)"
                      ResolvedRuntimeTargetsFiles="@(RuntimeTargetsCopyLocalItems)"
                      IsSelfContained="$(SelfContained)"
                      IncludeRuntimeFileVersions="$(IncludeFileVersionsInDependencyFile)"
                      DepsFileGenerationMode="$(DepsFileGenerationMode)">
    </GenerateDepsFile>

    <ItemGroup>
      <!-- Do this in an ItemGroup instead of as an output parameter of the GenerateDepsFile task so that it still gets added to the item set
           during incremental builds when the task is skipped -->
      <FileWrites Include="$(ProjectDepsFilePath)" Condition="Exists('$(ProjectDepsFilePath)')"/>
    </ItemGroup>
  </Target>

  <!--
    ============================================================
                                        GenerateBuildRuntimeConfigurationFiles

    Generates the $(project).runtimeconfig.json and $(project).runtimeconfig.dev.json files during Build
    ============================================================
    -->

  <Target Name="GenerateBuildRuntimeConfigurationFiles"
          DependsOnTargets="_DefaultMicrosoftNETPlatformLibrary"
          BeforeTargets="CopyFilesToOutputDirectory"
          Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'"
          Inputs="@(GenerateRuntimeConfigurationFilesInputs)"
          Outputs="$(ProjectRuntimeConfigFilePath);$(ProjectRuntimeConfigDevFilePath)">

    <GenerateRuntimeConfigurationFiles AssetsFilePath="$(ProjectAssetsFile)"
                                       TargetFrameworkMoniker="$(TargetFrameworkMoniker)"
                                       TargetFramework="$(TargetFramework)"
                                       RuntimeConfigPath="$(ProjectRuntimeConfigFilePath)"
                                       RuntimeConfigDevPath="$(ProjectRuntimeConfigDevFilePath)"
                                       RuntimeIdentifier="$(RuntimeIdentifier)"
                                       PlatformLibraryName="$(MicrosoftNETPlatformLibrary)"
                                       RuntimeFrameworks="@(RuntimeFramework)"
                                       UserRuntimeConfig="$(UserRuntimeConfig)"
                                       HostConfigurationOptions="@(RuntimeHostConfigurationOption)"
                                       AdditionalProbingPaths="@(AdditionalProbingPath)"
                                       IsSelfContained="$(SelfContained)">

    </GenerateRuntimeConfigurationFiles>

    <ItemGroup>
      <!-- Do this in an ItemGroup instead of as an output parameter of the GenerateDepsFile task so that it still gets added to the item set
          during incremental builds when the task is skipped -->
      <FileWrites Include="$(ProjectRuntimeConfigFilePath)" Condition="Exists('$(ProjectRuntimeConfigFilePath)')"/>
      <FileWrites Include="$(ProjectRuntimeConfigDevFilePath)" Condition="Exists('$(ProjectRuntimeConfigDevFilePath)')"/>
    </ItemGroup>

  </Target>

  <!-- Add runtimeconfig.json file to BuiltProjectOutputGroupOutput, so that it will get included in the NuGet package by the Pack target -->
  <Target Name="AddRuntimeConfigFileToBuiltProjectOutputGroupOutput"
          Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'"
          BeforeTargets="BuiltProjectOutputGroup">
    <ItemGroup>
      <BuiltProjectOutputGroupOutput Include="$(ProjectRuntimeConfigFilePath)" 
                                     TargetPath="$(ProjectRuntimeConfigFileName)"
                                     FinalOutputPath="$(ProjectRuntimeConfigFilePath)" />
    </ItemGroup>
  </Target>

  <Target Name="_SdkBeforeClean">
    <PropertyGroup Condition="'$(_CleaningWithoutRebuilding)' == ''">
      <_CleaningWithoutRebuilding>true</_CleaningWithoutRebuilding>
      <EmitAssetsLogMessages>false</EmitAssetsLogMessages>
    </PropertyGroup>
  </Target>

  <Target Name="_SdkBeforeRebuild">
    <PropertyGroup>
      <_CleaningWithoutRebuilding>false</_CleaningWithoutRebuilding>
    </PropertyGroup>
  </Target>

  <!--
    ============================================================
                                        DefaultRuntimeHostConfigurationOptions

    Defaults @(RuntimeHostConfigurationOption) items based on MSBuild properties.
    ============================================================
    -->

  <ItemGroup>
    <RuntimeHostConfigurationOption Include="System.GC.Concurrent"
                                    Condition="'$(ConcurrentGarbageCollection)' != ''"
                                    Value="$(ConcurrentGarbageCollection)" />

    <RuntimeHostConfigurationOption Include="System.GC.Server"
                                    Condition="'$(ServerGarbageCollection)' != ''"
                                    Value="$(ServerGarbageCollection)" />

    <RuntimeHostConfigurationOption Include="System.GC.RetainVM"
                                    Condition="'$(RetainVMGarbageCollection)' != ''"
                                    Value="$(RetainVMGarbageCollection)" />

    <RuntimeHostConfigurationOption Include="System.Runtime.TieredCompilation"
                                    Condition="'$(TieredCompilation)' != ''"
                                    Value="$(TieredCompilation)" />

    <RuntimeHostConfigurationOption Include="System.Runtime.TieredCompilation.QuickJit"
                                    Condition="'$(TieredCompilationQuickJit)' != ''"
                                    Value="$(TieredCompilationQuickJit)" />

    <RuntimeHostConfigurationOption Include="System.Threading.ThreadPool.MinThreads"
                                    Condition="'$(ThreadPoolMinThreads)' != ''"
                                    Value="$(ThreadPoolMinThreads)" />

    <RuntimeHostConfigurationOption Include="System.Threading.ThreadPool.MaxThreads"
                                    Condition="'$(ThreadPoolMaxThreads)' != ''"
                                    Value="$(ThreadPoolMaxThreads)" />
  
    <RuntimeHostConfigurationOption Include="System.Globalization.Invariant"
                                    Condition="'$(InvariantGlobalization)' != ''"
                                    Value="$(InvariantGlobalization)" />
  </ItemGroup>

  <!--
    ============================================================
                                        DefaultAdditionalProbingPaths

    Adds the default @(AdditionalProbingPath) items.
    ============================================================
    -->

  <ItemGroup Condition="'$(GenerateRuntimeConfigurationFiles)' == 'true' and '$(SkipDefaultAdditionalProbingPaths)' != 'true'">
    <!-- Note: can't use Path.Combine here since `|` is an illegal path character -->
    <AdditionalProbingPath Include="$(UserProfileRuntimeStorePath)$([System.IO.Path]::DirectorySeparatorChar)|arch|$([System.IO.Path]::DirectorySeparatorChar)|tfm|" />
  </ItemGroup>

  <PropertyGroup>
    <CompileDependsOn>
      $(CompileDependsOn);
      _CreateAppHost;
      _CreateComHost;
    </CompileDependsOn>
  </PropertyGroup>

  <!--
    ============================================================
                                        _CreateAppHost
    If we found a restored apphost, create the modified destination apphost
    with options from the project.
    ============================================================
     -->
  <UsingTask TaskName="CreateAppHost" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <Target Name="_CreateAppHost"
          Inputs="@(IntermediateAssembly);$(AppHostSourcePath)"
          Outputs="$(AppHostIntermediatePath)"
          DependsOnTargets="_GetAppHostPaths;CoreCompile"
          Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and
                     '$(AppHostSourcePath)' != '' and
                     Exists('@(IntermediateAssembly)') and
                     Exists('$(AppHostSourcePath)')">
    <PropertyGroup>
      <_UseWindowsGraphicalUserInterface Condition="($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win'))) and '$(OutputType)'=='WinExe'">true</_UseWindowsGraphicalUserInterface>
    </PropertyGroup>
    <CreateAppHost AppHostSourcePath="$(AppHostSourcePath)"
                   AppHostDestinationPath="$(AppHostIntermediatePath)"
                   AppBinaryName="$(AssemblyName)$(TargetExt)"
                   IntermediateAssembly="@(IntermediateAssembly->'%(FullPath)')"
                   WindowsGraphicalUserInterface="$(_UseWindowsGraphicalUserInterface)" />
  </Target>

  <!--
    ============================================================
                                        _GetAppHostPaths

    Gets the path to apphost (restored via packages or in an apphost pack),
    and computes the path for the destination apphost.
    ============================================================
     -->
  <Target Name="_GetAppHostPaths"
          DependsOnTargets="ResolvePackageAssets"
          Condition="'$(UseAppHost)' == 'true' and '$(_IsExecutable)' == 'true'">

    <NETSdkError Condition="'@(_NativeRestoredAppHostNETCore->Count())' > 1"
             ResourceName="MultipleFilesResolved"
             FormatArguments="$(_DotNetAppHostExecutableName)" />

    <PropertyGroup>
      <!-- AppHostSourcePath will be set from ResolveFrameworkReferences if not using the apphost from the assets file -->
      <AppHostSourcePath Condition="'$(UseAppHostFromAssetsFile)' == 'true'">@(_NativeRestoredAppHostNETCore)</AppHostSourcePath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(UseAppHostFromAssetsFile)' == 'false' Or '@(_NativeRestoredAppHostNETCore)' != ''">
      <AppHostIntermediatePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)$(AssemblyName)$(_NativeExecutableExtension)'))</AppHostIntermediatePath>
    </PropertyGroup>
    
  </Target>

  <ItemGroup>
    <ClsidMap Include="$(IntermediateOutputPath)$(AssemblyName).clsidmap" />
    <RegFreeComManifest Include="$(IntermediateOutputPath)$(AssemblyName).X.manifest" />
  </ItemGroup>
  
  <!--
      ============================================================
                                        _GenerateClsidMap

    Generates a *.clsidmap file from the built assembly.
    ============================================================
  -->
  <UsingTask TaskName="GenerateClsidMap" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <Target Name="_GenerateClsidMap"
          Inputs="@(IntermediateAssembly)"
          Outputs="@(ClsidMap)"
          DependsOnTargets="CoreCompile"
          Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and
                     '$(UseComHost)' == 'true'">
    <GenerateClsidMap
        IntermediateAssembly="@(IntermediateAssembly->'%(FullPath)')"
        CLsidMapDestinationPath="@(ClsidMap->'%(FullPath)')" />
  </Target>

  <UsingTask TaskName="CreateComHost" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />

  <!--
    ============================================================
                                        _CreateComHost
    If we found a restored comhost, create the modified destination apphost
    with options from the project.
    ============================================================
     -->
  <Target Name="_CreateComHost"
          Inputs="@(IntermediateAssembly);$(ComHostSourcePath)"
          Outputs="$(ComHostIntermediatePath)"
          DependsOnTargets="_GetComHostPaths;CoreCompile;_GenerateClsidMap;_GenerateRegFreeComManifest"
          Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and
                     '$(ComHostIntermediatePath)' != '' and
                     Exists('@(IntermediateAssembly)') and
                     Exists('$(ComHostSourcePath)')">
    <CreateComHost
      ComHostSourcePath="$(ComHostSourcePath)"
      ComHostDestinationPath="$(ComHostIntermediatePath)"
      ClsidMapPath="@(ClsidMap)" />
  </Target>

  <UsingTask TaskName="GenerateRegFreeComManifest" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <!-- 
    ============================================================
                                        _GenerateRegFreeComManifest

    Gets the path to the restored comhost, and if the restored comhost
    was present, computes the path for the destination comhost.
    ============================================================
  -->
  <Target Name="_GenerateRegFreeComManifest"
          DependsOnTargets="_GenerateClsidMap;_GetComHostPaths"
          Inputs="@(ClsidMap);@(IntermediateAssembly)"
          Outputs="@(RegFreeComManifest)"
          Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and
                     '$(UseComHost)' == 'true' and
                     '$(EnableRegFreeCom)' == 'true'">
    <GenerateRegFreeComManifest
      IntermediateAssembly="@(IntermediateAssembly)"
      ComHostName="$(ComHostFileName)"
      ClsidMapPath="@(ClsidMap)"
      ComManifestPath="@(RegFreeComManifest)" />
  </Target>

  <!--
    ============================================================
                                        _GetComHostPaths

    Gets the path to the restored comhost, and if the restored comhost
    was present, computes the path for the destination comhost.
    ============================================================
     -->
  <Target Name="_GetComHostPaths"
          DependsOnTargets="ResolvePackageAssets"
          Condition="'$(UseComHost)' == 'true' and '$(_IsExecutable)' != 'true'">
    <PropertyGroup>
      <ComHostFileName>$(AssemblyName).comhost$(_ComHostLibraryExtension)</ComHostFileName>
      <ComHostIntermediatePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)$(ComHostFileName)'))</ComHostIntermediatePath>
    </PropertyGroup>

    <NETSdkError Condition="'$(ComHostSourcePath)' == '' or !Exists('$(ComHostSourcePath)')"
             ResourceName="CannotFindComhost" />
  </Target>
  
  <!--
    ============================================================
                                        _ComputeNETCoreBuildOutputFiles

    Computes any files that need to be copied to the build output folder for .NET Core.
    ============================================================
    -->
  <Target Name="_ComputeNETCoreBuildOutputFiles"
          DependsOnTargets="_GetAppHostPaths;_GetComHostPaths"
          BeforeTargets="AssignTargetPaths"
          Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true'">

    <!-- Fallback to renaming the dotnet host if there is no apphost for self-contained builds. -->
    <PropertyGroup Condition="'$(AppHostIntermediatePath)' == '' and '$(SelfContained)' == 'true'">
      <_CopyAndRenameDotnetHost Condition="'$(_CopyAndRenameDotnetHost)' == ''">true</_CopyAndRenameDotnetHost>
    </PropertyGroup>
    <ItemGroup Condition="'$(_CopyAndRenameDotnetHost)' == 'true'">
      <None Include="@(NativeCopyLocalItems)"
            Condition="'%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetHostExecutableName)'">
        <Link>$(AssemblyName)$(_NativeExecutableExtension)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
    </ItemGroup>


    <ItemGroup Condition="'$(AppHostIntermediatePath)' != '' or '$(_CopyAndRenameDotnetHost)' == 'true'">
      <!--
        If not copying local lock file assemblies, copy the host policy and host fxr libraries for self-contained builds.
        This is required to allow the host to activate in self-contained mode.
      -->
      <None Include="@(NativeCopyLocalItems)"
            Condition="'$(SelfContained)' == 'true' and
                       '$(CopyLocalLockFileAssemblies)' != 'true' and
                       ('%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetHostPolicyLibraryName)' or
                        '%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetHostFxrLibraryName)')">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>Never</CopyToPublishDirectory>
      </None>
    </ItemGroup>
    <ItemGroup Condition="'$(AppHostIntermediatePath)' != ''">
      <None Include="$(AppHostIntermediatePath)">
        <Link>$(AssemblyName)$(_NativeExecutableExtension)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
    </ItemGroup>
    
    <ItemGroup Condition="'$(ComHostIntermediatePath)' != ''">
      <None Include="$(ComHostIntermediatePath)">
        <Link>$(AssemblyName).$(_DotNetComHostLibraryName)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
      <None Include="@(RegFreeComManifest)" Condition="'$(EnableRegFreeCom)' == 'true'">
        <Link>%(FileName)%(Extension)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>

    </ItemGroup>
  </Target>

  <!--
    ============================================================
                                        _ComputeReferenceAssemblies

    Computes references that are only used at compile-time.
    ============================================================
    -->
  <Target Name="_ComputeReferenceAssemblies"
          DependsOnTargets="ResolveAssemblyReferences">

    <ItemGroup>
      <_FrameworkReferenceAssemblies Include="@(ReferencePath)"
                                     Condition="(%(ReferencePath.FrameworkFile) == 'true' or
                                                %(ReferencePath.ResolvedFrom) == 'ImplicitlyExpandDesignTimeFacades')
                                            and ('%(ReferencePath.NuGetSourceType)' == ''  or
                                                 '%(ReferencePath.NuGetIsFrameworkReference)' == 'true')" />

      <!--
      "ReferenceOnly" assemblies are assemblies that are only used at compile-time, and they can't be resolved
      by the normal compile-assembly resolvers at runtime:
      1. App local
      2. NuGet/Package layout
      3. ProgramFiles\Reference Assemblies
      These assemblies need to be copied to the 'refs' folder for both build and publish.
      -->
      <_ReferenceOnlyAssemblies Include="@(ReferencePath)"
                                Exclude="@(_FrameworkReferenceAssemblies)"
                                Condition="%(ReferencePath.CopyLocal) != 'true' and
                                           %(ReferencePath.NuGetSourceType) == ''" />

      <_ReferenceAssemblies Include="@(_FrameworkReferenceAssemblies)" />
      <_ReferenceAssemblies Include="@(_ReferenceOnlyAssemblies)" />
    </ItemGroup>

  </Target>

  <!--
    ============================================================
                                        Run Information

    The ProcessStart information that can be used to run this project.
    ============================================================
    -->

  <PropertyGroup>
    <RunWorkingDirectory Condition="'$(RunWorkingDirectory)' == ''">$(StartWorkingDirectory)</RunWorkingDirectory>
  </PropertyGroup>

  <Choose>
    <When Condition="'$(StartAction)' == 'Program'">
      <PropertyGroup>
        <RunCommand Condition="'$(RunCommand)' == ''">$(StartProgram)</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">$(StartArguments)</RunArguments>
      </PropertyGroup>
    </When>

    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_IsExecutable)' == 'true'">
      <PropertyGroup Condition="'$(UseAppHost)' != 'true'">
        <!-- TODO: https://github.com/dotnet/sdk/issues/20 Need to get the DotNetHost path from MSBuild -->
        <RunCommand Condition="'$(RunCommand)' == ''">dotnet</RunCommand>

        <_NetCoreRunArguments>exec &quot;$(TargetPath)&quot;</_NetCoreRunArguments>
        <RunArguments Condition="'$(RunArguments)' == '' and '$(StartArguments)' != ''">$(_NetCoreRunArguments) $(StartArguments)</RunArguments>
        <RunArguments Condition="'$(RunArguments)' == ''">$(_NetCoreRunArguments)</RunArguments>
      </PropertyGroup>

      <PropertyGroup Condition="'$(UseAppHost)' == 'true'">
        <RunCommand Condition="'$(RunCommand)' == ''">$(TargetDir)$(AssemblyName)$(_NativeExecutableExtension)</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">$(StartArguments)</RunArguments>
      </PropertyGroup>
    </When>

    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(_IsExecutable)' == 'true'">
      <PropertyGroup>
        <RunCommand Condition="'$(RunCommand)' == ''">$(TargetPath)</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">$(StartArguments)</RunArguments>
      </PropertyGroup>
    </When>
  </Choose>

  <PropertyGroup>
    <!-- Ensure $(RunWorkingDirectory) is a full path -->
    <RunWorkingDirectory Condition="'$(RunWorkingDirectory)' != '' and '$([System.IO.Path]::IsPathRooted($(RunWorkingDirectory)))' != 'true'">$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(RunWorkingDirectory)'))))</RunWorkingDirectory>
  </PropertyGroup>

  <!--
    ============================================================
                    CoreGenerateSatelliteAssemblies
    ============================================================
    -->
  <PropertyGroup>
    <CreateSatelliteAssembliesDependsOn>
      $(CreateSatelliteAssembliesDependsOn);
      CoreGenerateSatelliteAssemblies
    </CreateSatelliteAssembliesDependsOn>
  </PropertyGroup>

  <UsingTask TaskName="GetAssemblyAttributes" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />

  <Target Name="CoreGenerateSatelliteAssemblies"
          DependsOnTargets="ResolveAssemblyReferences;_GetAssemblyInfoFromTemplateFile"
          Inputs="$(MSBuildAllProjects);@(_SatelliteAssemblyResourceInputs);$(IntermediateOutputPath)$(TargetName)$(TargetExt)"
          Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll"
          Condition="'@(_SatelliteAssemblyResourceInputs)' != ''  and '$(GenerateSatelliteAssembliesForCore)' == 'true' ">

    <MakeDir Directories="@(_SatelliteAssemblyResourceInputs->'$(IntermediateOutputPath)%(Culture)')" />

    <PropertyGroup>
      <_AssemblyInfoFile>$(IntermediateOutputPath)%(_SatelliteAssemblyResourceInputs.Culture)\$(TargetName).resources.cs</_AssemblyInfoFile>
      <_OutputAssembly>$(IntermediateOutputPath)%(_SatelliteAssemblyResourceInputs.Culture)\$(TargetName).resources.dll</_OutputAssembly>
    </PropertyGroup>

    <ItemGroup>
      <SatelliteAssemblyAttribute Include="System.Reflection.AssemblyCultureAttribute" Condition="'%(_SatelliteAssemblyResourceInputs.Culture)' != ''">
        <_Parameter1>%(_SatelliteAssemblyResourceInputs.Culture)</_Parameter1>
      </SatelliteAssemblyAttribute>
    </ItemGroup>

    <WriteCodeFragment AssemblyAttributes="@(SatelliteAssemblyAttribute)" Language="C#" OutputFile="$(_AssemblyInfoFile)">
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </WriteCodeFragment>

    <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
      <UseSharedCompilation>true</UseSharedCompilation>
    </PropertyGroup>

    <Csc Resources="@(_SatelliteAssemblyResourceInputs)"
         Sources="$(_AssemblyInfoFile)"
         OutputAssembly="$(_OutputAssembly)"
         References="@(ReferencePath)"
         KeyContainer="$(KeyContainerName)"
         KeyFile="$(KeyOriginatorFile)"
         NoConfig="true"
         NoLogo="$(NoLogo)"
         NoStandardLib="$(NoCompilerStandardLib)"
         PublicSign="$(PublicSign)"
         DelaySign="$(DelaySign)"
         Deterministic="$(Deterministic)"
         DisabledWarnings="$(DisabledWarnings)"
         WarningLevel="$(WarningLevel)"
         WarningsAsErrors="$(WarningsAsErrors)"
         WarningsNotAsErrors="$(WarningsNotAsErrors)"
         TargetType="Library"
         ToolExe="$(CscToolExe)"
         ToolPath="$(CscToolPath)"
         UseSharedCompilation="$(UseSharedCompilation)">

      <Output TaskParameter="OutputAssembly" ItemName="FileWrites"/>
    </Csc>
  </Target>

  <Target Name="_GetAssemblyInfoFromTemplateFile">
    <GetAssemblyAttributes PathToTemplateFile="$(IntermediateOutputPath)$(TargetName)$(TargetExt)" >
      <Output TaskParameter="AssemblyAttributes" ItemName="_AssemblyAttributesFromTemplateFile" />
    </GetAssemblyAttributes>

    <ItemGroup>
      <SatelliteAssemblyAttribute Include="@(_AssemblyAttributesFromTemplateFile)" />
    </ItemGroup>

  </Target>

  <!--
  ============================================================
                           _DefaultMicrosoftNETPlatformLibrary

  .NET Core apps can have shared frameworks that are pre-installed on the target machine, thus the app is "portable"
  to any machine that already has the shared framework installed. For .NET Core 1.x and 2.x, a "platform" library
  is declared. The platform library and its dependencies will be excluded from the publish output.
  
  For .NET Core 3 and up, targeting packs and runtime packs are used for shared framework assets instead of PackageReference
  ============================================================
  -->
  <Target Name="_DefaultMicrosoftNETPlatformLibrary">

    <PropertyGroup Condition="'$(MicrosoftNETPlatformLibrary)' == ''">
      <MicrosoftNETPlatformLibrary Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'">Microsoft.NETCore.App</MicrosoftNETPlatformLibrary>
    </PropertyGroup>

  </Target>

  <!--
  ============================================================
                                      GetAllRuntimeIdentifiers
  ============================================================
  -->
  <Target Name="GetAllRuntimeIdentifiers"
          Returns="$(RuntimeIdentifiers);$(RuntimeIdentifier)" />

  <!--
  ============================================================
                                      InjectTargetPathMetadata

  Update TargetPathWithTargetPlatformMoniker with target framework
  identifier and version metadata.  This is so that the
  ImplicitlyExpandNETStandardFacades target can determine if a
  referenced project needs the .NET Standard facades even if
  the project hasn't been compiled to disk yet.

  See https://github.com/dotnet/sdk/issues/1403 for more context
  ============================================================
  -->

  <ItemDefinitionGroup>
    <TargetPathWithTargetPlatformMoniker>
      <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
      <TargetFrameworkVersion>$(_TargetFrameworkVersionWithoutV)</TargetFrameworkVersion>
    </TargetPathWithTargetPlatformMoniker>
  </ItemDefinitionGroup>

  <!--
  ============================================================
                                         Project Capabilities
  ============================================================
  -->

  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_IsExecutable)' == 'true'">
    <ProjectCapability Include="CrossPlatformExecutable" />
  </ItemGroup>

  <!-- Reference Manager capabilities -->
  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">
    <ProjectCapability Remove="ReferenceManagerAssemblies" />
    <ProjectCapability Remove="ReferenceManagerCOM" />
  </ItemGroup>

  <!-- Publish capabilities -->
  <ItemGroup>
    <ProjectCapability Include="FolderPublish" />
  </ItemGroup>

  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DisableStandardFrameworkResolution.targets" Condition="'$(DisableStandardFrameworkResolution)' == 'true'" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DesignerSupport.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.GenerateAssemblyInfo.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.GenerateSupportedRuntime.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.ComposeStore.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.CrossGen.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.ObsoleteReferences.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Publish.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackTool.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackProjectTool.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PreserveCompilationContext.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.ConflictResolution.targets" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.CSharp.targets" Condition="'$(Language)' == 'C#'" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.VisualBasic.targets" Condition="'$(Language)' == 'VB'" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.FSharp.targets" Condition="'$(Language)' == 'F#'" />
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.ILLink.targets" />
</Project>
