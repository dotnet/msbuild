// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Threading;
using Microsoft.Build.BackEnd.Logging;
using Microsoft.Build.Exceptions;
using Microsoft.Build.Framework;
using Microsoft.Build.Internal;
using Microsoft.Build.Shared;
#if FEATURE_REPORTFILEACCESSES
using Microsoft.Build.Experimental.FileAccess;
using Microsoft.Build.FileAccesses;
#endif

#nullable disable

namespace Microsoft.Build.BackEnd
{
    /// <summary>
    /// The wrapper task for tasks that wish to take advantage of the
    /// task host factory feature.  Generated by AssemblyTaskFactory
    /// when it wants to run the loaded task in the task host.
    /// </summary>
    internal class TaskHostTask : IGeneratedTask, ICancelableTask, INodePacketFactory, INodePacketHandler
    {
        /// <summary>
        /// Counter for generating unique task IDs across all TaskHostTask instances.
        /// Used for callback correlation when multiple tasks execute concurrently.
        /// </summary>
        private static int s_nextTaskId;

        /// <summary>
        /// The IBuildEngine callback object.
        /// </summary>
        private IBuildEngine _buildEngine;

        /// <summary>
        /// The host object that can be passed to this task.
        /// </summary>
        private ITaskHost _hostObject;

        /// <summary>
        /// Logging context for logging errors / issues
        /// encountered in the TaskHostTask itself.
        /// </summary>
        private TaskLoggingContext _taskLoggingContext;

        /// <summary>
        /// Location of the task in the project file.
        /// </summary>
        private IElementLocation _taskLocation;

        /// <summary>
        ///  The provider for the task host nodes.
        /// </summary>
        private IBuildComponentHost _buildComponentHost;

        /// <summary>
        /// The packet factory.
        /// </summary>
        private NodePacketFactory _packetFactory;

        /// <summary>
        /// The event which is set when we receive packets.
        /// </summary>
        private AutoResetEvent _packetReceivedEvent;

        /// <summary>
        /// The packet that is the end result of the task host task execution process
        /// </summary>
        private ConcurrentQueue<INodePacket> _receivedPackets;

        /// <summary>
        /// The set of parameters used to decide which host to launch.
        /// </summary>
        private TaskHostParameters _taskHostParameters;

        /// <summary>
        /// The type of the task that we are wrapping.
        /// </summary>
        private LoadedType _taskType;

#if FEATURE_APPDOMAIN
        /// <summary>
        /// The AppDomainSetup we'll want to apply to the AppDomain that we may
        /// want to load the OOP task into.
        /// </summary>
        private AppDomainSetup _appDomainSetup;
#endif

        /// <summary>
        /// The task host context of the task host we're launching -- used to
        /// communicate with the task host.
        /// </summary>
        private HandshakeOptions _requiredContext = HandshakeOptions.None;

        /// <summary>
        /// The task host node key identifying the task host we're launching.
        /// </summary>
        private TaskHostNodeKey _taskHostNodeKey;

        /// <summary>
        /// The unique ID of this task, used for correlating TaskHostTaskComplete packets
        /// in nested build scenarios where multiple tasks may run in the same TaskHost.
        /// </summary>
        private int _taskId;

        /// <summary>
        /// The ID of the node on which this task is scheduled to run.
        /// </summary>
        private readonly int _scheduledNodeId;

        /// <summary>
        /// True if currently connected to the task host; false otherwise.
        /// </summary>
        private bool _connectedToTaskHost = false;

        /// <summary>
        /// The provider for task host nodes.
        /// </summary>
        private NodeProviderOutOfProcTaskHost _taskHostProvider;

        /// <summary>
        /// Lock object to serialize access to the task host.
        /// </summary>
        private LockType _taskHostLock;

        /// <summary>
        /// Keeps track of whether the wrapped task has had cancel called against it.
        /// </summary>
        private bool _taskCancelled;

        /// <summary>
        /// The set of parameters that has been set to this wrapped task -- save them
        /// here so that we can forward them on to the task host.
        /// </summary>
        private IDictionary<string, object> _setParameters;

        /// <summary>
        /// Did the task succeed?
        /// </summary>
        private bool _taskExecutionSucceeded = false;

        /// <summary>
        /// If true TaskHostFactory expects the TaskHost not will NOT expire after build (until it timeouts or is killed).
        /// This is relevant for the next cases:
        /// 1) TaskHostFactory is NOT explicitly requested (we always disable node reuse due to the transient nature of task host factory hosts).
        /// 2) Runtime="NET" is specified in UsingTask.
        /// 3) Environment variable MSBUILDFORCEALLTASKSOUTOFPROC is set.
        /// </summary>
        private bool _useSidecarTaskHost = false;

        /// <summary>
        /// The task environment for virtualized environment operations.
        /// </summary>
        private readonly TaskEnvironment _taskEnvironment;

        /// <summary>
        /// Constructor.
        /// </summary>
        public TaskHostTask(
            IElementLocation taskLocation,
            TaskLoggingContext taskLoggingContext,
            IBuildComponentHost buildComponentHost,
            TaskHostParameters taskHostParameters,
            LoadedType taskType,
            bool useSidecarTaskHost,
#if FEATURE_APPDOMAIN
            AppDomainSetup appDomainSetup,
#endif
            int scheduledNodeId,
            TaskEnvironment taskEnvironment)
        {
            ErrorUtilities.VerifyThrowInternalNull(taskType);
            ErrorUtilities.VerifyThrowInternalNull(taskEnvironment);

            _scheduledNodeId = scheduledNodeId;

            _taskLocation = taskLocation;
            _taskLoggingContext = taskLoggingContext;
            _buildComponentHost = buildComponentHost;
            _taskType = taskType;
#if FEATURE_APPDOMAIN
            _appDomainSetup = appDomainSetup;
#endif
            _taskHostParameters = taskHostParameters;
            _useSidecarTaskHost = useSidecarTaskHost;
            _taskEnvironment = taskEnvironment;

            _packetFactory = new NodePacketFactory();

            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.LogMessage, LogMessagePacket.FactoryForDeserialization, this);
            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.TaskHostTaskComplete, TaskHostTaskComplete.FactoryForDeserialization, this);
            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeShutdown, NodeShutdown.FactoryForDeserialization, this);
            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.TaskHostQueryRequest, TaskHostQueryRequest.FactoryForDeserialization, this);
            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.TaskHostResourceRequest, TaskHostResourceRequest.FactoryForDeserialization, this);
            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.TaskHostBuildRequest, TaskHostBuildRequest.FactoryForDeserialization, this);
            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.TaskHostYieldRequest, TaskHostYieldRequest.FactoryForDeserialization, this);

            _packetReceivedEvent = new AutoResetEvent(false);
            _receivedPackets = new ConcurrentQueue<INodePacket>();
            _taskHostLock = new();

            _setParameters = new Dictionary<string, object>();
        }

        /// <summary>
        /// THe IBuildEngine callback object
        /// </summary>
        public IBuildEngine BuildEngine
        {
            get
            {
                return _buildEngine;
            }

            set
            {
                _buildEngine = value;
            }
        }

        /// <summary>
        /// The host object that can be passed to this task.
        /// </summary>
        public ITaskHost HostObject
        {
            get
            {
                return _hostObject;
            }

            set
            {
                _hostObject = value;
            }
        }

        /// <summary>
        /// Gets information about the assembly from which the task type was loaded.
        /// </summary>
        public AssemblyLoadInfo LoadedTaskAssemblyInfo => _taskType.Assembly;

        /// <summary>
        /// Sets the requested task parameter to the requested value.
        /// </summary>
        public void SetPropertyValue(TaskPropertyInfo property, object value)
        {
            _setParameters[property.Name] = value;
        }

        /// <summary>
        /// Returns the value of the requested task parameter
        /// </summary>
        public object GetPropertyValue(TaskPropertyInfo property)
        {
            if (_setParameters.TryGetValue(property.Name, out object value))
            {
                // If we returned an exception, then we want to throw it when we
                // do the get.
                if (value is Exception ex)
                {
                    throw ex;
                }

                return value;
            }
            else
            {
                PropertyInfo parameter = _taskType.Type.GetProperty(property.Name, BindingFlags.Instance | BindingFlags.Public);
                return parameter.GetValue(this, null);
            }
        }

        /// <summary>
        /// Cancels the currently executing task
        /// </summary>
        public void Cancel()
        {
            if (!_taskCancelled)
            {
                lock (_taskHostLock)
                {
                    if (_taskHostProvider != null && _connectedToTaskHost)
                    {
                        _taskHostProvider.SendData(_taskHostNodeKey, new TaskHostTaskCancelled());
                    }
                }

                _taskCancelled = true;
            }
        }

        /// <summary>
        /// Executes the task.
        /// </summary>
        public bool Execute()
        {
            _taskLoggingContext.LogComment(
                MessageImportance.Low,
                "ExecutingTaskInTaskHost",
                _taskType.Type.Name,
                _taskType.Assembly.AssemblyLocation,
                _taskHostParameters.Runtime,
                _taskHostParameters.Architecture);

            // set up the node
            lock (_taskHostLock)
            {
                _taskHostProvider = (NodeProviderOutOfProcTaskHost)_buildComponentHost.GetComponent(BuildComponentType.OutOfProcTaskHostNodeProvider);
                ErrorUtilities.VerifyThrowInternalNull(_taskHostProvider, "taskHostProvider");
            }

            string taskLocation = AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly);
            if (string.IsNullOrEmpty(taskLocation))
            {
                // fall back to the AssemblyLoadInfo location for inline tasks loaded from bytes
                taskLocation = _taskType?.Assembly?.AssemblyLocation ?? string.Empty;
            }

            TaskHostConfiguration hostConfiguration =
                new TaskHostConfiguration(
                        _buildComponentHost.BuildParameters.NodeId,
                        _taskEnvironment.ProjectDirectory,
                        (IDictionary<string, string>)_taskEnvironment.GetEnvironmentVariables(),
                        _buildComponentHost.BuildParameters.Culture,
                        _buildComponentHost.BuildParameters.UICulture,
#if FEATURE_APPDOMAIN
                        _appDomainSetup,
#endif
                        BuildEngine.LineNumberOfTaskNode,
                        BuildEngine.ColumnNumberOfTaskNode,
                        BuildEngine.ProjectFileOfTaskNode,
                        BuildEngine.ContinueOnError,
                        _taskType.Type.FullName,
                        taskLocation,
                        _buildComponentHost.BuildParameters.LogTaskInputs,
                        _setParameters,
                        new Dictionary<string, string>(_buildComponentHost.BuildParameters.GlobalProperties),
                        _taskLoggingContext.GetWarningsAsErrors(),
                        _taskLoggingContext.GetWarningsNotAsErrors(),
                        _taskLoggingContext.GetWarningsAsMessages());

            // Assign unique task ID for callback correlation
            _taskId = Interlocked.Increment(ref s_nextTaskId);
            hostConfiguration.TaskId = _taskId;

            try
            {
                lock (_taskHostLock)
                {
                    _requiredContext = CommunicationsUtilities.GetHandshakeOptions(
                        taskHost: true,

                        // Determine if we should use node reuse based on build parameters or user preferences (comes from UsingTask element).
                        nodeReuse: _buildComponentHost.BuildParameters.EnableNodeReuse && _useSidecarTaskHost,
                        taskHostParameters: _taskHostParameters);

                    _taskHostNodeKey = new TaskHostNodeKey(_requiredContext, _scheduledNodeId);
                    _connectedToTaskHost = _taskHostProvider.AcquireAndSetUpHost(_taskHostNodeKey, this, this, hostConfiguration, _taskHostParameters);
                }

                if (_connectedToTaskHost)
                {
                    try
                    {
                        bool taskFinished = false;

                        while (!taskFinished)
                        {
                            _packetReceivedEvent.WaitOne();

                            INodePacket packet = null;

                            // Handle the packet that's coming in
                            while (_receivedPackets.TryDequeue(out packet))
                            {
                                if (packet != null)
                                {
                                    HandlePacket(packet, out taskFinished);
                                    // When our task completes, immediately disconnect from host
                                    // to remove us from the handler stack. This prevents packets
                                    // meant for other handlers from being routed to us in nested scenarios.
                                    if (taskFinished)
                                    {
                                        lock (_taskHostLock)
                                        {
                                            _taskHostProvider.DisconnectFromHost(_taskHostNodeKey);
                                            _connectedToTaskHost = false;
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    finally
                    {
                        // DisconnectFromHost may have already been called above
                        lock (_taskHostLock)
                        {
                            if (_connectedToTaskHost)
                            {
                                _taskHostProvider.DisconnectFromHost(_taskHostNodeKey);
                                _connectedToTaskHost = false;
                            }
                        }
                    }
                }
                else
                {
                    LogErrorUnableToCreateTaskHost(_requiredContext, _taskHostParameters.Runtime, _taskHostParameters.Architecture, null);
                }
            }
            catch (BuildAbortedException)
            {
                LogErrorUnableToCreateTaskHost(_requiredContext, _taskHostParameters.Runtime, _taskHostParameters.Architecture, null);
            }
            catch (NodeFailedToLaunchException e)
            {
                LogErrorUnableToCreateTaskHost(_requiredContext, _taskHostParameters.Runtime, _taskHostParameters.Architecture, e);
            }

            return _taskExecutionSucceeded;
        }

        /// <summary>
        /// Registers the specified handler for a particular packet type.
        /// </summary>
        /// <param name="packetType">The packet type.</param>
        /// <param name="factory">The factory for packets of the specified type.</param>
        /// <param name="handler">The handler to be called when packets of the specified type are received.</param>
        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)
        {
            _packetFactory.RegisterPacketHandler(packetType, factory, handler);
        }

        /// <summary>
        /// Unregisters a packet handler.
        /// </summary>
        /// <param name="packetType">The packet type.</param>
        public void UnregisterPacketHandler(NodePacketType packetType)
        {
            _packetFactory.UnregisterPacketHandler(packetType);
        }

        /// <summary>
        /// Takes a serializer, deserializes the packet and routes it to the appropriate handler.
        /// </summary>
        /// <param name="nodeId">The node from which the packet was received.</param>
        /// <param name="packetType">The packet type.</param>
        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
        {
            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
        }

        /// <summary>
        /// Takes a serializer and deserializes the packet.
        /// </summary>
        /// <param name="packetType">The packet type.</param>
        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
        {
            return _packetFactory.DeserializePacket(packetType, translator);
        }

        /// <summary>
        /// Routes the specified packet
        /// </summary>
        /// <param name="nodeId">The node from which the packet was received.</param>
        /// <param name="packet">The packet to route.</param>
        public void RoutePacket(int nodeId, INodePacket packet)
        {
            _packetFactory.RoutePacket(nodeId, packet);
        }

        /// <summary>
        /// This method is invoked by the NodePacketRouter when a packet is received and is intended for
        /// this recipient.
        /// </summary>
        /// <param name="node">The node from which the packet was received.</param>
        /// <param name="packet">The packet.</param>
        public void PacketReceived(int node, INodePacket packet)
        {
            _receivedPackets.Enqueue(packet);
            _packetReceivedEvent.Set();
        }

        /// <summary>
        /// Called by TaskHostFactory to let the task know that if it needs to do any additional cleanup steps,
        /// now would be the time.
        /// </summary>
        internal void Cleanup()
        {
            // for now, do nothing.
        }

        /// <summary>
        /// Handles the packets received from the task host.
        /// </summary>
        private void HandlePacket(INodePacket packet, out bool taskFinished)
        {
            Debug.WriteLine("[TaskHostTask] Handling packet {0} at {1}", packet.Type, DateTime.Now);
            taskFinished = false;

            switch (packet.Type)
            {
                case NodePacketType.TaskHostTaskComplete:
                    HandleTaskHostTaskComplete(packet as TaskHostTaskComplete, out taskFinished);
                    break;
                case NodePacketType.NodeShutdown:
                    HandleNodeShutdown(packet as NodeShutdown);
                    taskFinished = true;
                    break;
                case NodePacketType.LogMessage:
                    HandleLoggedMessage(packet as LogMessagePacket);
                    break;
                case NodePacketType.TaskHostQueryRequest:
                    HandleQueryRequest(packet as TaskHostQueryRequest);
                    break;
                case NodePacketType.TaskHostResourceRequest:
                    HandleResourceRequest(packet as TaskHostResourceRequest);
                    break;
                case NodePacketType.TaskHostBuildRequest:
                    HandleBuildRequest(packet as TaskHostBuildRequest);
                    break;
                case NodePacketType.TaskHostYieldRequest:
                    HandleYieldRequest(packet as TaskHostYieldRequest);
                    break;
                default:
                    ErrorUtilities.ThrowInternalErrorUnreachable();
                    break;
            }
        }

        /// <summary>
        /// Task completed executing in the task host
        /// </summary>
        private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplete, out bool taskFinished)
        {
            // Check if this completion is for our task or a nested task.
            // In nested BuildProjectFile scenarios, multiple tasks can run in the same TaskHost,
            // and we only want to process completions for our specific task.
            if (taskHostTaskComplete.TaskId != 0 && taskHostTaskComplete.TaskId != _taskId)
            {
                // This completion is for a different task (likely a nested task from BuildProjectFile).
                // Don't mark our task as finished - just return.
                taskFinished = false;
                return;
            }

            taskFinished = true;
#if FEATURE_REPORTFILEACCESSES
            if (taskHostTaskComplete.FileAccessData?.Count > 0)
            {
                IFileAccessManager fileAccessManager = ((IFileAccessManager)_buildComponentHost.GetComponent(BuildComponentType.FileAccessManager));
                foreach (FileAccessData fileAccessData in taskHostTaskComplete.FileAccessData)
                {
                    fileAccessManager.ReportFileAccess(fileAccessData, _buildComponentHost.BuildParameters.NodeId);
                }
            }
#endif

            // If it crashed, or if it failed, it didn't succeed.
            _taskExecutionSucceeded = taskHostTaskComplete.TaskResult == TaskCompleteType.Success ? true : false;

            // Update the task environment with the environment changes from the task host execution
            _taskEnvironment.SetEnvironment(taskHostTaskComplete.BuildProcessEnvironment);

            // If it crashed during the execution phase, then we can effectively replicate the inproc task execution
            // behaviour by just throwing here and letting the taskbuilder code take care of it the way it would
            // have normally.
            // We will also replicate the same behaviour if the TaskHost caught some exceptions after execution of the task.
            if ((taskHostTaskComplete.TaskResult == TaskCompleteType.CrashedDuringExecution) ||
                (taskHostTaskComplete.TaskResult == TaskCompleteType.CrashedAfterExecution))
            {
                throw new TargetInvocationException(taskHostTaskComplete.TaskException);
            }

            // On the other hand, if it crashed during initialization, there's not really a way to effectively replicate
            // the inproc behavior -- in the inproc case, the task would have failed to load and crashed long before now.
            // Furthermore, if we were just to throw here like in the execution case, we'd lose the ability to log
            // different messages based on the circumstances of the initialization failure -- whether it was a setter failure,
            // the task just could not be loaded, etc.

            // So instead, when we catch the exception in the task host, we'll also record what message we want it to use
            // when the error is logged; and given that information, log that error here.  This has the effect of differing
            // from the inproc case insofar as ContinueOnError is now respected, instead of forcing a stop here.
            if (taskHostTaskComplete.TaskResult == TaskCompleteType.CrashedDuringInitialization)
            {
                string exceptionMessage;
                string[] exceptionMessageArgs;

                if (taskHostTaskComplete.TaskExceptionMessage != null)
                {
                    exceptionMessage = taskHostTaskComplete.TaskExceptionMessage;
                    exceptionMessageArgs = taskHostTaskComplete.TaskExceptionMessageArgs;
                }
                else
                {
                    exceptionMessageArgs = [_taskType.Type.Name,
                        AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly),
                        string.Empty];
                }

                _taskLoggingContext.LogFatalError(taskHostTaskComplete.TaskException, new BuildEventFileInfo(_taskLocation), taskHostTaskComplete.TaskExceptionMessage, taskHostTaskComplete.TaskExceptionMessageArgs);
            }

            // Set the output parameters for later
            foreach (KeyValuePair<string, TaskParameter> outputParam in taskHostTaskComplete.TaskOutputParameters)
            {
                _setParameters[outputParam.Key] = outputParam.Value?.WrappedParameter;
            }
        }

        /// <summary>
        /// The task host node failed for some reason
        /// </summary>
        private void HandleNodeShutdown(NodeShutdown nodeShutdown)
        {
            // if the task was canceled, it may send the shutdown packet before the task itself has exited --
            // in this case, the shutdown is expected, so don't log errors.  Also don't update taskExecutionSucceeded,
            // as it has already been set properly (likely also to false) when we dealt with the TaskComplete
            // packet that was sent immediately prior to this.
            if (!_taskCancelled)
            {
                // nothing much else to say.
                _taskExecutionSucceeded = false;

                _taskLoggingContext.LogError(new BuildEventFileInfo(_taskLocation), "TaskHostExitedPrematurely", (nodeShutdown.Exception == null) ? String.Empty : nodeShutdown.Exception.ToString());
            }
        }

        /// <summary>
        /// Handle logged messages from the task host.
        /// </summary>
        private void HandleLoggedMessage(LogMessagePacket logMessagePacket)
        {
            switch (logMessagePacket.EventType)
            {
                case LoggingEventType.BuildErrorEvent:
                    this.BuildEngine.LogErrorEvent((BuildErrorEventArgs)logMessagePacket.NodeBuildEvent.Value.Value);
                    break;
                case LoggingEventType.BuildWarningEvent:
                    this.BuildEngine.LogWarningEvent((BuildWarningEventArgs)logMessagePacket.NodeBuildEvent.Value.Value);
                    break;
                case LoggingEventType.TaskCommandLineEvent:
                case LoggingEventType.BuildMessageEvent:
                    this.BuildEngine.LogMessageEvent((BuildMessageEventArgs)logMessagePacket.NodeBuildEvent.Value.Value);
                    break;
                case LoggingEventType.CustomEvent:
                    BuildEventArgs buildEvent = logMessagePacket.NodeBuildEvent.Value.Value;

                    // "Custom events" in terms of the communications infrastructure can also be, e.g. custom error events,
                    // in which case they need to be dealt with in the same way as their base type of event.
                    if (buildEvent is BuildErrorEventArgs buildErrorEventArgs)
                    {
                        this.BuildEngine.LogErrorEvent(buildErrorEventArgs);
                    }
                    else if (buildEvent is BuildWarningEventArgs buildWarningEventArgs)
                    {
                        this.BuildEngine.LogWarningEvent(buildWarningEventArgs);
                    }
                    else if (buildEvent is BuildMessageEventArgs buildMessageEventArgs)
                    {
                        this.BuildEngine.LogMessageEvent(buildMessageEventArgs);
                    }
                    else if (buildEvent is CustomBuildEventArgs customBuildEventArgs)
                    {
                        this.BuildEngine.LogCustomEvent(customBuildEventArgs);
                    }
                    else
                    {
                        ErrorUtilities.ThrowInternalError("Unknown event args type.");
                    }

                    break;
            }
        }

        /// <summary>
        /// Handle query requests from the TaskHost for simple build engine state.
        /// </summary>
        private void HandleQueryRequest(TaskHostQueryRequest request)
        {
            bool result = request.Query switch
            {
                TaskHostQueryRequest.QueryType.IsRunningMultipleNodes
                    => _buildEngine is IBuildEngine2 engine2 && engine2.IsRunningMultipleNodes,
                _ => false  // Unknown query type - return safe default
            };

            var response = new TaskHostQueryResponse(request.RequestId, result);
            _taskHostProvider.SendData(_taskHostNodeKey, response);
        }

        /// <summary>
        /// Handles resource requests (RequestCores/ReleaseCores) from the TaskHost.
        /// </summary>
        private void HandleResourceRequest(TaskHostResourceRequest request)
        {
            int result = 0;

            switch (request.Operation)
            {
                case TaskHostResourceRequest.ResourceOperation.RequestCores:
                    result = _buildEngine is IBuildEngine9 engine9
                        ? engine9.RequestCores(request.CoreCount)
                        : request.CoreCount; // Fallback: grant all if old engine
                    break;

                case TaskHostResourceRequest.ResourceOperation.ReleaseCores:
                    if (_buildEngine is IBuildEngine9 releaseEngine9)
                    {
                        releaseEngine9.ReleaseCores(request.CoreCount);
                    }
                    result = request.CoreCount; // Acknowledgment
                    break;
            }

            var response = new TaskHostResourceResponse(request.RequestId, result);
            _taskHostProvider.SendData(_taskHostNodeKey, response);
        }

        /// <summary>
        /// Handles BuildProjectFile* requests from the TaskHost.
        /// Forwards the request to the real build engine and sends back the response.
        /// This method runs the build on a separate thread to avoid blocking the packet
        /// handling loop, which is necessary when nested builds need to communicate
        /// with the same TaskHost (e.g., send logs or new task configurations).
        /// </summary>
        private void HandleBuildRequest(TaskHostBuildRequest request)
        {
            bool result = false;
            IDictionary targetOutputs = null;
            IDictionary[] targetOutputsPerProject = null;
            IList<IDictionary<string, ITaskItem[]>> buildEngineResultOutputs = null;

            try
            {
                switch (request.Variant)
                {
                    case TaskHostBuildRequest.BuildRequestVariant.BuildEngine1:
                        targetOutputs = new Hashtable(StringComparer.OrdinalIgnoreCase);
                        result = _buildEngine.BuildProjectFile(
                            request.ProjectFileName,
                            request.TargetNames,
                            ConvertToIDictionary(request.GlobalProperties),
                            targetOutputs);
                        break;

                    case TaskHostBuildRequest.BuildRequestVariant.BuildEngine2Single:
                        targetOutputs = new Hashtable(StringComparer.OrdinalIgnoreCase);
                        if (_buildEngine is IBuildEngine2 engine2Single)
                        {
                            result = engine2Single.BuildProjectFile(
                                request.ProjectFileName,
                                request.TargetNames,
                                ConvertToIDictionary(request.GlobalProperties),
                                targetOutputs,
                                request.ToolsVersion);
                        }
                        else
                        {
                            // Fallback: ignore toolsVersion
                            result = _buildEngine.BuildProjectFile(
                                request.ProjectFileName,
                                request.TargetNames,
                                ConvertToIDictionary(request.GlobalProperties),
                                targetOutputs);
                        }
                        break;

                    case TaskHostBuildRequest.BuildRequestVariant.BuildEngine2Parallel:
                        if (_buildEngine is IBuildEngine2 engine2Parallel)
                        {
                            int projectCount = request.ProjectFileNames?.Length ?? 0;
                            targetOutputsPerProject = new IDictionary[projectCount];
                            for (int i = 0; i < projectCount; i++)
                            {
                                targetOutputsPerProject[i] = new Hashtable(StringComparer.OrdinalIgnoreCase);
                            }

                            result = engine2Parallel.BuildProjectFilesInParallel(
                                request.ProjectFileNames,
                                request.TargetNames,
                                ConvertToIDictionaryArray(request.GlobalPropertiesArray),
                                targetOutputsPerProject,
                                request.ToolsVersions,
                                request.UseResultsCache,
                                request.UnloadProjectsOnCompletion);
                        }
                        else
                        {
                            // No IBuildEngine2 - return failure
                            result = false;
                        }
                        break;

                    case TaskHostBuildRequest.BuildRequestVariant.BuildEngine3Parallel:
                        if (_buildEngine is IBuildEngine3 engine3)
                        {
                            BuildEngineResult engineResult = engine3.BuildProjectFilesInParallel(
                                request.ProjectFileNames,
                                request.TargetNames,
                                ConvertToIDictionaryArray(request.GlobalPropertiesArray),
                                ConvertToIListArray(request.RemoveGlobalProperties),
                                request.ToolsVersions,
                                request.ReturnTargetOutputs);
                            result = engineResult.Result;
                            buildEngineResultOutputs = engineResult.TargetOutputsPerProject;
                        }
                        else
                        {
                            // No IBuildEngine3 - return failure
                            result = false;
                        }
                        break;

                    default:
                        ErrorUtilities.ThrowInternalErrorUnreachable();
                        break;
                }
            }
            catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
            {
                // Don't crash on exceptions - just return failure to the TaskHost.
                // The task will receive result=false and can decide how to handle it.
                // Any actual error messages would have been logged by the build engine itself.
                result = false;
            }

            // Send response - use the appropriate constructor based on output type
            TaskHostBuildResponse response;
            if (buildEngineResultOutputs != null)
            {
                // IBuildEngine3 result
                response = new TaskHostBuildResponse(request.RequestId, result, buildEngineResultOutputs);
            }
            else if (targetOutputsPerProject != null)
            {
                // IBuildEngine2 parallel result
                response = new TaskHostBuildResponse(request.RequestId, result, targetOutputsPerProject);
            }
            else
            {
                // Single project result
                response = new TaskHostBuildResponse(request.RequestId, result, targetOutputs);
            }

            _taskHostProvider.SendData(_taskHostNodeKey, response);
        }

        /// <summary>
        /// Handles Yield/Reacquire requests from the TaskHost.
        ///
        /// Yield/Reacquire flow:
        /// 1. TaskHost task calls Yield() → sends YieldRequest(Yield) → returns immediately
        /// 2. Parent (this) receives YieldRequest(Yield) → calls _buildEngine.Yield() → no response sent
        /// 3. TaskHost task does non-build work...
        /// 4. TaskHost task calls Reacquire() → sends YieldRequest(Reacquire) → blocks waiting
        /// 5. Parent (this) receives YieldRequest(Reacquire) → calls _buildEngine.Reacquire() (may block)
        /// 6. When _buildEngine.Reacquire() returns → sends YieldResponse → TaskHost unblocks
        /// </summary>
        private void HandleYieldRequest(TaskHostYieldRequest request)
        {
            switch (request.Operation)
            {
                case YieldOperation.Yield:
                    // Forward yield to the real build engine - fire and forget
                    if (_buildEngine is IBuildEngine3 engine3)
                    {
                        engine3.Yield();
                    }
                    // No response - Yield is fire-and-forget
                    break;

                case YieldOperation.Reacquire:
                    // Forward reacquire to the real build engine
                    // This may block until the scheduler allows the task to continue
                    if (_buildEngine is IBuildEngine3 engine3Reacquire)
                    {
                        engine3Reacquire.Reacquire();
                    }
                    // Send acknowledgment to TaskHost to unblock the yielded task
                    var response = new TaskHostYieldResponse(request.RequestId, success: true);
                    _taskHostProvider.SendData(_taskHostNodeKey, response);
                    break;
            }
        }

        /// <summary>
        /// Converts Dictionary&lt;string, string&gt; to IDictionary (Hashtable) for IBuildEngine calls.
        /// </summary>
        private static IDictionary ConvertToIDictionary(Dictionary<string, string> source)
        {
            if (source == null)
            {
                return null;
            }

            var result = new Hashtable(source.Count, StringComparer.OrdinalIgnoreCase);
            foreach (KeyValuePair<string, string> kvp in source)
            {
                result[kvp.Key] = kvp.Value;
            }
            return result;
        }

        /// <summary>
        /// Converts array of Dictionary&lt;string, string&gt; to array of IDictionary.
        /// </summary>
        private static IDictionary[] ConvertToIDictionaryArray(Dictionary<string, string>[] source)
        {
            if (source == null)
            {
                return null;
            }

            var result = new IDictionary[source.Length];
            for (int i = 0; i < source.Length; i++)
            {
                result[i] = ConvertToIDictionary(source[i]);
            }
            return result;
        }

        /// <summary>
        /// Converts array of List&lt;string&gt; to array of IList&lt;string&gt;.
        /// </summary>
        private static IList<string>[] ConvertToIListArray(List<string>[] source)
        {
            if (source == null)
            {
                return null;
            }

            // List<string> implements IList<string>, so we can just cast
            var result = new IList<string>[source.Length];
            for (int i = 0; i < source.Length; i++)
            {
                result[i] = source[i];
            }
            return result;
        }

        /// <summary>
        /// Since we log that we weren't able to connect to the task host in a couple of different places,
        /// extract it out into a separate method.
        /// </summary>
        private void LogErrorUnableToCreateTaskHost(HandshakeOptions requiredContext, string runtime, string architecture, NodeFailedToLaunchException e)
        {
            string taskHostLocation = NodeProviderOutOfProcTaskHost.GetMSBuildExecutablePathForNonNETRuntimes(requiredContext);
#if NETFRAMEWORK
            if (Handshake.IsHandshakeOptionEnabled(requiredContext, HandshakeOptions.NET))
            {
                taskHostLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationForNETRuntime(requiredContext, _taskHostParameters).MSBuildAssemblyPath;
            }
#endif
            string msbuildLocation = taskHostLocation ??
                // We don't know the path -- probably we're trying to get a 64-bit assembly on a
                // 32-bit machine.  At least give them the exe name to look for, though ...
                ((requiredContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2 
                ? "MSBuildTaskHost.exe" 
                : NodeProviderOutOfProcTaskHost.GetTaskHostNameFromHostContext(requiredContext));

            if (e == null)
            {
                _taskLoggingContext.LogError(new BuildEventFileInfo(_taskLocation), "TaskHostAcquireFailed", _taskType.Type.Name, runtime, architecture, msbuildLocation);
            }
            else
            {
                _taskLoggingContext.LogError(new BuildEventFileInfo(_taskLocation), "TaskHostNodeFailedToLaunch", _taskType.Type.Name, runtime, architecture, msbuildLocation, e.ErrorCode, e.Message);
            }
        }
    }
}
