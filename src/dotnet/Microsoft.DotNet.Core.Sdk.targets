<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <MicrosoftDotNetCoreBuildTasksDirectoryRoot>$(MSBuildThisFileDirectory)../../lib/</MicrosoftDotNetCoreBuildTasksDirectoryRoot>
    <MicrosoftDotNetCoreBuildTasksTFM Condition=" '$(MSBuildRuntimeType)' == 'Core'">netstandard1.6</MicrosoftDotNetCoreBuildTasksTFM>
    <MicrosoftDotNetCoreBuildTasksTFM Condition=" '$(MicrosoftDotNetCoreBuildTasksTFM)' == ''">net451</MicrosoftDotNetCoreBuildTasksTFM>
    <MicrosoftDotNetCoreBuildTasksDirectory>$(MicrosoftDotNetCoreBuildTasksDirectoryRoot)$(MicrosoftDotNetCoreBuildTasksTFM)/</MicrosoftDotNetCoreBuildTasksDirectory>

	<!-- If the build task directory doesn't exist (since we aren't in a NuGet package), load the task assembly in the tools path -->
    <MicrosoftDotNetCoreBuildTasksDirectory Condition=" !Exists('$(MicrosoftDotNetCoreBuildTasksDirectory)') ">$(MSBuildToolsPath)/</MicrosoftDotNetCoreBuildTasksDirectory>
</PropertyGroup>

  <PropertyGroup>
    <!-- We don't use any of MSBuild's resolution logic for resolving the framework, so just set these two
              properties to any folder that exists to skip the GetReferenceAssemblyPaths task (not target) and
              to prevent it from outputting a warning (MSB3644).
          -->
    <_TargetFrameworkDirectories>$(MSBuildThisFileDirectory)</_TargetFrameworkDirectories>
    <_FullFrameworkReferenceAssemblyPaths>$(MSBuildThisFileDirectory)</_FullFrameworkReferenceAssemblyPaths>
  </PropertyGroup>

  <PropertyGroup>
    <GenerateRuntimeConfigurationFiles Condition=" '$(GenerateRuntimeConfigurationFiles)' == '' and '$(OutputType)' == 'exe' ">true</GenerateRuntimeConfigurationFiles>
    <Version Condition=" '$(Version)' == '' ">1.0.0</Version>
  </PropertyGroup>

  <UsingTask TaskName="GenerateDepsFile" AssemblyFile="$(MicrosoftDotNetCoreBuildTasksDirectory)Microsoft.DotNet.Core.Build.Tasks.dll" />
  <UsingTask TaskName="GenerateRuntimeConfigurationFiles" AssemblyFile="$(MicrosoftDotNetCoreBuildTasksDirectory)Microsoft.DotNet.Core.Build.Tasks.dll" />
             
  <PropertyGroup>
    <CoreBuildDependsOn>
      $(CoreBuildDependsOn);
      GenerateDependencyFile;
      GenerateRuntimeConfigurationFiles
    </CoreBuildDependsOn>
  </PropertyGroup>

  <Target Name="GenerateDependencyFile"
          Condition=" '$(GenerateDependencyFile)' == 'true'">
    <!--
    TODO: Is this the best way? Should we just tell CSC to output $(AssemblyName).dll directly?
    -->
    <Move SourceFiles="$(TargetPath)" DestinationFiles="$(TargetDir)/$(AssemblyName).dll" />

    <!--
    TODO: Get RuntimeIdentifier
    -->
    <GenerateDepsFile LockFilePath="$(MSBuildProjectDirectory)/project.lock.json"
                      DepsFilePath="$(TargetDir)$(AssemblyName).deps.json"
                      TargetFramework="$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion)"
                      AssemblyName="$(AssemblyName)"
                      AssemblyVersion="$(Version)"
                      RuntimeIdentifier="" />

    <!--
    TODO: When OutputType == 'exe' and !IsPortable, we need to verify CoreClr is present in the deps graph, and copy in a host to the output
    See https://github.com/dotnet/cli/blob/6b54ae0bcc5c63e7c989ac19d851f234f9172bea/src/Microsoft.DotNet.Compiler.Common/Executable.cs#L102-L107
    -->
  </Target>

  <Target Name="GenerateRuntimeConfigurationFiles"
        Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'">

    <!--
    TODO: Get RawRuntimeOptions from where it lives in the MSBuild world
    -->
    <GenerateRuntimeConfigurationFiles LockFilePath="$(MSBuildProjectDirectory)/project.lock.json"
                                       RuntimeOutputPath="$(TargetDir)"
                                       AssemblyName="$(AssemblyName)"
                                       RawRuntimeOptions=""
                                       IncludeDevConfig="true" />

  </Target>

  <!--
    ============================================================
                                        GetRunInformation

    Returns the ProcessStart information that can be used to run this project.
    ============================================================
    -->

  <Target Name="GetRunInformation"
          DependsOnTargets="GenerateRunInformation"
          Outputs="@(RunInformation)" />

  <Target Name="GenerateRunInformation">
    <ItemGroup>
      <RunInformation Include="$(MSBuildProjectFullPath)">
	    <!-- TODO: Need to get the Muxer path from MSBuild -->
        <CommandName>dotnet</CommandName>
        <Args>exec;$(TargetDir)/$(AssemblyName).dll</Args>
      </RunInformation>
    </ItemGroup>
  </Target>

  <!--
    ============================================================
                                        Publish

    Override the "in-box" publish, which is very ClickOnce centric.
    ============================================================
    -->

  <PropertyGroup>
    <PublishDependsOn>
      Build;
      CopyPublishArtifacts
    </PublishDependsOn>

    <PublishDir Condition=" '$(PublishDir)' == '' ">$(OutDir)publish\</PublishDir>
  </PropertyGroup>

  <Target
      Name="Publish"
      DependsOnTargets="$(PublishDependsOn)" />

  <Target Name="CopyPublishArtifacts">
    <Message Text="TODO: Implement CopyPublishArtifacts" />
  </Target>
</Project>
